$NetBSD: patch-ab,v 1.8 2008/02/08 23:15:16 bjs Exp $

--- dbus/dbus-sysdeps-unix.c.orig	2006-12-11 14:21:09.000000000 -0500
+++ dbus/dbus-sysdeps-unix.c
@@ -22,6 +22,10 @@
  *
  */
 
+#ifdef __NetBSD__
+#define _NETBSD_SOURCE
+#endif
+
 #include "dbus-internals.h"
 #include "dbus-sysdeps.h"
 #include "dbus-sysdeps-unix.h"
@@ -67,6 +71,10 @@
 #include <ucred.h>
 #endif
 
+#ifdef __NetBSD__
+#include <sys/un.h>
+#endif
+
 #ifndef O_BINARY
 #define O_BINARY 0
 #endif
@@ -75,6 +83,33 @@
 #define socklen_t int
 #endif
 
+#ifdef LOCAL_PEEREID
+static dbus_bool_t
+dbus_nb_getpeereid(int fd, pid_t *pid, uid_t *uid, gid_t *gid)
+{
+  struct unpcbid cred;
+  socklen_t len = sizeof(cred);
+
+  _dbus_verbose ("dbus_nb_getpeereid: enter, fd=%d\n", fd);
+
+  if (getsockopt(fd, 0, LOCAL_PEEREID, &cred, &len) < 0)
+    {
+      _dbus_verbose ("dbus_nb_getpeereid: getsockopt LOCAL_PEEREID failed: %s\n", strerror(errno));
+      return FALSE;
+    }
+  if (pid)
+    *pid = cred.unp_pid;
+  if (uid)
+    *uid = cred.unp_euid;
+  if (gid)
+    *gid = cred.unp_egid;
+
+  _dbus_verbose ("dbus_nb_getpeereid: returning TRUE, pid=%d uid=%d gid=%d\n",
+		 cred.unp_pid, cred.unp_euid, cred.unp_egid);
+  return TRUE;
+}
+#endif
+
 static dbus_bool_t
 _dbus_open_socket (int              *fd,
                    int               domain,
@@ -517,7 +552,7 @@ _dbus_set_local_creds (int fd, dbus_bool
 {
   dbus_bool_t retval = TRUE;
 
-#if defined(HAVE_CMSGCRED)
+#if defined(HAVE_CMSGCRED) || defined(LOCAL_PEEREID)
   /* NOOP just to make sure only one codepath is used 
    *      and to prefer CMSGCRED
    */
@@ -955,7 +990,7 @@ _dbus_read_credentials_unix_socket  (int
   msg.msg_iov = &iov;
   msg.msg_iovlen = 1;
 
-#if defined(HAVE_CMSGCRED) || defined(LOCAL_CREDS)
+#if (defined(HAVE_CMSGCRED) || defined(LOCAL_CREDS)) && !defined(LOCAL_PEEREID)
   memset (&cmsg, 0, sizeof (cmsg));
   msg.msg_control = &cmsg;
   msg.msg_controllen = sizeof (cmsg);
@@ -980,7 +1015,7 @@ _dbus_read_credentials_unix_socket  (int
       return FALSE;
     }
 
-#if defined(HAVE_CMSGCRED) || defined(LOCAL_CREDS)
+#if (defined(HAVE_CMSGCRED) || defined(LOCAL_CREDS)) && !defined(LOCAL_PEEREID)
   if (cmsg.hdr.cmsg_len < sizeof (cmsg) || cmsg.hdr.cmsg_type != SCM_CREDS)
     {
       dbus_set_error (error, DBUS_ERROR_FAILED,
@@ -1012,6 +1047,19 @@ _dbus_read_credentials_unix_socket  (int
     credentials->pid = cmsg.cred.cmcred_pid;
     credentials->uid = cmsg.cred.cmcred_euid;
     credentials->gid = cmsg.cred.cmcred_groups[0];
+#elif defined(LOCAL_PEEREID)
+    pid_t sockpid, sockuid, sockgid;
+    if (dbus_nb_getpeereid(client_fd, &sockpid, &sockuid, &sockgid) == TRUE)
+      {
+	credentials->pid = sockpid;
+	credentials->uid = sockuid;
+	credentials->gid = sockgid;
+      }
+    else
+      {
+	_dbus_verbose ("Failed to dbus_nb_getpeereid() credentials\n");
+      }
+      
 #elif defined(LOCAL_CREDS)
     credentials->pid = DBUS_PID_UNSET;
     credentials->uid = cmsg.cred.sc_uid;
@@ -2311,8 +2359,18 @@ int
 _dbus_printf_string_upper_bound (const char *format,
                                  va_list     args)
 {
+#ifdef __hpux
+/* this code from libnbcompat's vsnprintf */
+  static FILE *devnull = 0;
+  if (!devnull) {
+    devnull = fopen("/dev/null", "w");
+    if (!devnull) return -1;
+  }
+  return vfprintf(devnull, format, args);
+#else
   char c;
   return vsnprintf (&c, 1, format, args);
+#endif
 }
 
 /**
