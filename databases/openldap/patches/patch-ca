$NetBSD: patch-ca,v 1.1 2008/09/07 12:18:07 wiz Exp $

BDB 4.7 support based on
http://www.openldap.org/lists/openldap-commit/200808/msg00045.html
http://www.openldap.org/lists/openldap-commit/200808/msg00048.html

Index: add.c
===================================================================
RCS file: /repo/OpenLDAP/pkg/ldap/servers/slapd/back-bdb/add.c,v
retrieving revision 1.173
retrieving revision 1.174
diff -u -r1.173 -r1.174
--- servers/slapd/back-bdb/add.c	1 May 2008 11:25:15 -0000	1.173
+++ servers/slapd/back-bdb/add.c	26 Aug 2008 23:45:35 -0000	1.174
@@ -32,11 +32,10 @@
 	size_t textlen = sizeof textbuf;
 	AttributeDescription *children = slap_schema.si_ad_children;
 	AttributeDescription *entry = slap_schema.si_ad_entry;
-	DB_TXN		*ltid = NULL, *lt2;
+	DB_TXN		*ltid = NULL, *lt2, *rtxn;
 	ID eid = NOID;
 	struct bdb_op_info opinfo = {0};
 	int subentry;
-	BDB_LOCKER	locker = 0, rlocker = 0;
 	DB_LOCK		lock;
 
 	int		num_retries = 0;
@@ -115,8 +114,8 @@
 
 	subentry = is_entry_subentry( op->oq_add.rs_e );
 
-	/* Get our thread locker ID */
-	rs->sr_err = LOCK_ID( bdb->bi_dbenv, &rlocker );
+	/* Get our reader TXN */
+	rs->sr_err = bdb_reader_get( op, bdb->bi_dbenv, &rtxn );
 
 	if( 0 ) {
 retry:	/* transaction retry */
@@ -157,8 +156,6 @@
 		goto return_results;
 	}
 
-	locker = TXN_ID ( ltid );
-
 	opinfo.boi_oe.oe_key = bdb;
 	opinfo.boi_txn = ltid;
 	opinfo.boi_err = 0;
@@ -176,7 +173,7 @@
 
 	/* get entry or parent */
 	rs->sr_err = bdb_dn2entry( op, ltid, &op->ora_e->e_nname, &ei,
-		1, locker, &lock );
+		1, &lock );
 	switch( rs->sr_err ) {
 	case 0:
 		rs->sr_err = LDAP_ALREADY_EXISTS;
@@ -428,8 +425,8 @@
 			nrdn = op->ora_e->e_nname;
 		}
 
-		/* Use the thread locker here, outside the txn */
-		bdb_cache_add( bdb, ei, op->ora_e, &nrdn, rlocker, &lock );
+		/* Use the reader txn here, outside the add txn */
+		bdb_cache_add( bdb, ei, op->ora_e, &nrdn, rtxn, &lock );
 
 		if(( rs->sr_err=TXN_COMMIT( ltid, 0 )) != 0 ) {
 			rs->sr_text = "txn_commit failed";
Index: back-bdb.h
===================================================================
RCS file: /repo/OpenLDAP/pkg/ldap/servers/slapd/back-bdb/back-bdb.h,v
retrieving revision 1.173
retrieving revision 1.174
diff -u -r1.173 -r1.174
--- servers/slapd/back-bdb/back-bdb.h	1 May 2008 10:49:35 -0000	1.173
+++ servers/slapd/back-bdb/back-bdb.h	26 Aug 2008 23:45:35 -0000	1.174
@@ -58,30 +58,6 @@
 #define	BDB_PAGESIZE	4096	/* BDB's original default */
 #endif
 
-/* 4.6.18 redefines cursor->locker */
-#if DB_VERSION_FULL >= 0x04060012
-
-struct __db_locker {
-	u_int32_t	id;
-};
-
-typedef struct __db_locker * BDB_LOCKER;
-
-extern int __lock_getlocker(DB_LOCKTAB *lt, u_int32_t locker, int create, DB_LOCKER **ret);
-
-#define CURSOR_SETLOCKER(cursor, id)	cursor->locker = id
-#define CURSOR_GETLOCKER(cursor)	cursor->locker
-#define BDB_LOCKID(locker)	locker->id
-#else
-
-typedef u_int32_t BDB_LOCKER;
-
-#define CURSOR_SETLOCKER(cursor, id)	cursor->locker = id
-#define CURSOR_GETLOCKER(cursor)	cursor->locker
-#define BDB_LOCKID(locker)	locker
-
-#endif
-
 #define DEFAULT_CACHE_SIZE     1000
 
 /* The default search IDL stack cache depth */
@@ -160,7 +136,7 @@
 	int		c_eiused;	/* EntryInfo's in use */
 	int		c_leaves;	/* EntryInfo leaf nodes */
 	int		c_purging;
-	BDB_LOCKER	c_locker;	/* used by lru cleaner */
+	DB_TXN	*c_txn;	/* used by lru cleaner */
 	ldap_pvt_thread_rdwr_t c_rwlock;
 	ldap_pvt_thread_mutex_t c_lru_mutex;
 	ldap_pvt_thread_mutex_t c_count_mutex;
@@ -309,12 +285,6 @@
 	((db)->open)(db, NULL, file, name, type, flags, mode)
 #endif
 
-/* BDB 4.6.18 makes locker a struct instead of an int */
-#if DB_VERSION_FULL >= 0x04060012
-#undef TXN_ID
-#define TXN_ID(txn)	(txn)->locker
-#endif
-
 /* #undef BDB_LOG_DEBUG */
 
 #ifdef BDB_LOG_DEBUG
@@ -343,8 +313,6 @@
 #define DB_BUFFER_SMALL			ENOMEM
 #endif
 
-#define BDB_REUSE_LOCKERS
-
 #define BDB_CSN_COMMIT	0
 #define BDB_CSN_ABORT	1
 #define BDB_CSN_RETRY	2
Index: bind.c
===================================================================
RCS file: /repo/OpenLDAP/pkg/ldap/servers/slapd/back-bdb/bind.c,v
retrieving revision 1.54
retrieving revision 1.55
diff -u -r1.54 -r1.55
--- servers/slapd/back-bdb/bind.c	7 Jan 2008 23:20:10 -0000	1.54
+++ servers/slapd/back-bdb/bind.c	26 Aug 2008 23:45:35 -0000	1.55
@@ -32,7 +32,7 @@
 
 	AttributeDescription *password = slap_schema.si_ad_userPassword;
 
-	BDB_LOCKER	locker;
+	DB_TXN		*rtxn;
 	DB_LOCK		lock;
 
 	Debug( LDAP_DEBUG_ARGS,
@@ -55,7 +55,7 @@
 		break;
 	}
 
-	rs->sr_err = LOCK_ID(bdb->bi_dbenv, &locker);
+	rs->sr_err = bdb_reader_get(op, bdb->bi_dbenv, &rtxn);
 	switch(rs->sr_err) {
 	case 0:
 		break;
@@ -67,8 +67,8 @@
 
 dn2entry_retry:
 	/* get entry with reader lock */
-	rs->sr_err = bdb_dn2entry( op, NULL, &op->o_req_ndn, &ei, 1,
-		locker, &lock );
+	rs->sr_err = bdb_dn2entry( op, rtxn, &op->o_req_ndn, &ei, 1,
+		&lock );
 
 	switch(rs->sr_err) {
 	case DB_NOTFOUND:
@@ -76,14 +76,12 @@
 		break;
 	case LDAP_BUSY:
 		send_ldap_error( op, rs, LDAP_BUSY, "ldap_server_busy" );
-		LOCK_ID_FREE(bdb->bi_dbenv, locker);
 		return LDAP_BUSY;
 	case DB_LOCK_DEADLOCK:
 	case DB_LOCK_NOTGRANTED:
 		goto dn2entry_retry;
 	default:
 		send_ldap_error( op, rs, LDAP_OTHER, "internal error" );
-		LOCK_ID_FREE(bdb->bi_dbenv, locker);
 		return rs->sr_err;
 	}
 
@@ -97,8 +95,6 @@
 		rs->sr_err = LDAP_INVALID_CREDENTIALS;
 		send_ldap_result( op, rs );
 
-		LOCK_ID_FREE(bdb->bi_dbenv, locker);
-
 		return rs->sr_err;
 	}
 
@@ -158,8 +154,6 @@
 		bdb_cache_return_entry_r( bdb, e, &lock );
 	}
 
-	LOCK_ID_FREE(bdb->bi_dbenv, locker);
-
 	if ( rs->sr_err ) {
 		send_ldap_result( op, rs );
 		if ( rs->sr_ref ) {
Index: cache.c
===================================================================
RCS file: /repo/OpenLDAP/pkg/ldap/servers/slapd/back-bdb/cache.c,v
retrieving revision 1.180
retrieving revision 1.182
diff -u -r1.180 -r1.182
--- servers/slapd/back-bdb/cache.c	1 May 2008 21:02:52 -0000	1.180
+++ servers/slapd/back-bdb/cache.c	27 Aug 2008 20:28:16 -0000	1.182
@@ -159,7 +159,7 @@
 int
 bdb_cache_entry_db_relock(
 	struct bdb_info *bdb,
-	BDB_LOCKER locker,
+	DB_TXN *txn,
 	EntryInfo *ei,
 	int rw,
 	int tryOnly,
@@ -183,7 +183,7 @@
 	list[1].lock = *lock;
 	list[1].mode = rw ? DB_LOCK_WRITE : DB_LOCK_READ;
 	list[1].obj = &lockobj;
-	rc = bdb->bi_dbenv->lock_vec(bdb->bi_dbenv, BDB_LOCKID(locker), tryOnly ? DB_LOCK_NOWAIT : 0,
+	rc = bdb->bi_dbenv->lock_vec(bdb->bi_dbenv, TXN_ID(txn), tryOnly ? DB_LOCK_NOWAIT : 0,
 		list, 2, NULL );
 
 	if (rc && !tryOnly) {
@@ -198,7 +198,7 @@
 }
 
 static int
-bdb_cache_entry_db_lock( struct bdb_info *bdb, BDB_LOCKER locker, EntryInfo *ei,
+bdb_cache_entry_db_lock( struct bdb_info *bdb, DB_TXN *txn, EntryInfo *ei,
 	int rw, int tryOnly, DB_LOCK *lock )
 {
 #ifdef NO_DB_LOCK
@@ -218,7 +218,7 @@
 	lockobj.data = &ei->bei_id;
 	lockobj.size = sizeof(ei->bei_id) + 1;
 
-	rc = LOCK_GET(bdb->bi_dbenv, BDB_LOCKID(locker), tryOnly ? DB_LOCK_NOWAIT : 0,
+	rc = LOCK_GET(bdb->bi_dbenv, TXN_ID(txn), tryOnly ? DB_LOCK_NOWAIT : 0,
 					&lockobj, db_rw, lock);
 	if (rc && !tryOnly) {
 		Debug( LDAP_DEBUG_TRACE,
@@ -394,7 +394,7 @@
 int
 bdb_cache_find_ndn(
 	Operation	*op,
-	BDB_LOCKER		locker,
+	DB_TXN		*txn,
 	struct berval	*ndn,
 	EntryInfo	**res )
 {
@@ -448,7 +448,7 @@
 				ei.bei_nrdn.bv_val );
 
 			lock.mode = DB_LOCK_NG;
-			rc = bdb_dn2id( op, &ei.bei_nrdn, &ei, locker, &lock );
+			rc = bdb_dn2id( op, &ei.bei_nrdn, &ei, txn, &lock );
 			if (rc) {
 				bdb_cache_entryinfo_lock( eip );
 				bdb_cache_entry_db_unlock( bdb, &lock );
@@ -508,7 +508,7 @@
 int
 hdb_cache_find_parent(
 	Operation *op,
-	BDB_LOCKER	locker,
+	DB_TXN	*txn,
 	ID id,
 	EntryInfo **res )
 {
@@ -521,7 +521,7 @@
 	ei.bei_ckids = 0;
 
 	for (;;) {
-		rc = hdb_dn2id_parent( op, locker, &ei, &eip.bei_id );
+		rc = hdb_dn2id_parent( op, txn, &ei, &eip.bei_id );
 		if ( rc ) break;
 
 		/* Save the previous node, if any */
@@ -668,7 +668,7 @@
 		return;
 	}
 
-	if ( bdb->bi_cache.c_locker ) {
+	if ( bdb->bi_cache.c_txn ) {
 		lockp = &lock;
 	} else {
 		lockp = NULL;
@@ -715,7 +715,7 @@
 		 * the object is idle.
 		 */
 		if ( bdb_cache_entry_db_lock( bdb,
-			bdb->bi_cache.c_locker, elru, 1, 1, lockp ) == 0 ) {
+			bdb->bi_cache.c_txn, elru, 1, 1, lockp ) == 0 ) {
 
 			/* Free entry for this node if it's present */
 			if ( elru->bei_e ) {
@@ -793,7 +793,6 @@
 	ID				id,
 	EntryInfo	**eip,
 	int		flag,
-	BDB_LOCKER	locker,
 	DB_LOCK		*lock )
 {
 	struct bdb_info *bdb = (struct bdb_info *) op->o_bd->be_private;
@@ -842,9 +841,9 @@
 	/* See if the ID exists in the database; add it to the cache if so */
 	if ( !*eip ) {
 #ifndef BDB_HIER
-		rc = bdb_id2entry( op->o_bd, tid, locker, id, &ep );
+		rc = bdb_id2entry( op->o_bd, tid, id, &ep );
 		if ( rc == 0 ) {
-			rc = bdb_cache_find_ndn( op, locker,
+			rc = bdb_cache_find_ndn( op, tid,
 				&ep->e_nname, eip );
 			if ( *eip ) flag |= ID_LOCKED;
 			if ( rc ) {
@@ -858,7 +857,7 @@
 			}
 		}
 #else
-		rc = hdb_cache_find_parent(op, locker, id, eip );
+		rc = hdb_cache_find_parent(op, tid, id, eip );
 		if ( rc == 0 ) flag |= ID_LOCKED;
 #endif
 	}
@@ -902,14 +901,14 @@
 				bdb_cache_entryinfo_unlock( *eip );
 				flag ^= ID_LOCKED;
 			}
-			rc = bdb_cache_entry_db_lock( bdb, locker, *eip, load, 0, lock );
+			rc = bdb_cache_entry_db_lock( bdb, tid, *eip, load, 0, lock );
 			if ( (*eip)->bei_state & CACHE_ENTRY_DELETED ) {
 				rc = DB_NOTFOUND;
 				bdb_cache_entry_db_unlock( bdb, lock );
 			} else if ( rc == 0 ) {
 				if ( load ) {
 					if ( !ep) {
-						rc = bdb_id2entry( op->o_bd, tid, locker, id, &ep );
+						rc = bdb_id2entry( op->o_bd, tid, id, &ep );
 					}
 					if ( rc == 0 ) {
 						ep->e_private = *eip;
@@ -934,7 +933,7 @@
 					}
 					if ( rc == 0 ) {
 						/* If we succeeded, downgrade back to a readlock. */
-						rc = bdb_cache_entry_db_relock( bdb, locker,
+						rc = bdb_cache_entry_db_relock( bdb, tid,
 							*eip, 0, 0, lock );
 					} else {
 						/* Otherwise, release the lock. */
@@ -955,12 +954,12 @@
 					rc = bdb_fix_dn( (*eip)->bei_e, 1 );
 					if ( rc ) {
 						bdb_cache_entry_db_relock( bdb,
-							locker, *eip, 1, 0, lock );
+							tid, *eip, 1, 0, lock );
 						/* check again in case other modifier did it already */
 						if ( bdb_fix_dn( (*eip)->bei_e, 1 ) )
 							rc = bdb_fix_dn( (*eip)->bei_e, 2 );
 						bdb_cache_entry_db_relock( bdb,
-							locker, *eip, 0, 0, lock );
+							tid, *eip, 0, 0, lock );
 					}
 #endif
 				}
@@ -1039,7 +1038,7 @@
 	EntryInfo *eip,
 	Entry *e,
 	struct berval *nrdn,
-	BDB_LOCKER locker,
+	DB_TXN *txn,
 	DB_LOCK *lock )
 {
 	EntryInfo *new, ei;
@@ -1056,7 +1055,7 @@
 	/* Lock this entry so that bdb_add can run to completion.
 	 * It can only fail if BDB has run out of lock resources.
 	 */
-	rc = bdb_cache_entry_db_lock( bdb, locker, &ei, 0, 0, lock );
+	rc = bdb_cache_entry_db_lock( bdb, txn, &ei, 0, 0, lock );
 	if ( rc ) {
 		bdb_cache_entryinfo_unlock( eip );
 		return rc;
@@ -1114,13 +1113,13 @@
 	struct bdb_info *bdb,
 	Entry *e,
 	Attribute *newAttrs,
-	BDB_LOCKER locker,
+	DB_TXN *txn,
 	DB_LOCK *lock )
 {
 	EntryInfo *ei = BEI(e);
 	int rc;
 	/* Get write lock on data */
-	rc = bdb_cache_entry_db_relock( bdb, locker, ei, 1, 0, lock );
+	rc = bdb_cache_entry_db_relock( bdb, txn, ei, 1, 0, lock );
 
 	/* If we've done repeated mods on a cached entry, then e_attrs
 	 * is no longer contiguous with the entry, and must be freed.
@@ -1144,7 +1143,7 @@
 	struct berval *nrdn,
 	Entry *new,
 	EntryInfo *ein,
-	BDB_LOCKER locker,
+	DB_TXN *txn,
 	DB_LOCK *lock )
 {
 	EntryInfo *ei = BEI(e), *pei;
@@ -1154,7 +1153,7 @@
 #endif
 
 	/* Get write lock on data */
-	rc =  bdb_cache_entry_db_relock( bdb, locker, ei, 1, 0, lock );
+	rc =  bdb_cache_entry_db_relock( bdb, txn, ei, 1, 0, lock );
 	if ( rc ) return rc;
 
 	/* If we've done repeated mods on a cached entry, then e_attrs
@@ -1249,7 +1248,7 @@
 bdb_cache_delete(
 	struct bdb_info *bdb,
     Entry		*e,
-    BDB_LOCKER	locker,
+    DB_TXN *txn,
     DB_LOCK	*lock )
 {
 	EntryInfo *ei = BEI(e);
@@ -1266,7 +1265,7 @@
 	bdb_cache_entryinfo_unlock( ei );
 
 	/* Get write lock on the data */
-	rc = bdb_cache_entry_db_relock( bdb, locker, ei, 1, 0, lock );
+	rc = bdb_cache_entry_db_relock( bdb, txn, ei, 1, 0, lock );
 	if ( rc ) {
 		/* couldn't lock, undo and give up */
 		ei->bei_state ^= CACHE_ENTRY_DELETED;
@@ -1436,56 +1435,36 @@
 #endif
 #endif
 
-#ifdef BDB_REUSE_LOCKERS
 static void
-bdb_locker_id_free( void *key, void *data )
+bdb_reader_free( void *key, void *data )
 {
-	DB_ENV *env = key;
-	u_int32_t lockid;
-	int rc;
+	/* DB_ENV *env = key; */
+	DB_TXN *txn = data;
 
-#if DB_VERSION_FULL >= 0x04060012
-	BDB_LOCKER lptr = data;
-	lockid = lptr->id;
-#else
-	lockid = (long)data;
-#endif
-	rc = XLOCK_ID_FREE( env, lockid );
-	if ( rc == EINVAL ) {
-		DB_LOCKREQ lr;
-		Debug( LDAP_DEBUG_ANY,
-			"bdb_locker_id_free: %lu err %s(%d)\n",
-			(unsigned long) lockid, db_strerror(rc), rc );
-		/* release all locks held by this locker. */
-		lr.op = DB_LOCK_PUT_ALL;
-		lr.obj = NULL;
-		env->lock_vec( env, lockid, 0, &lr, 1, NULL );
-		XLOCK_ID_FREE( env, lockid );
-	}
+	TXN_ABORT( txn );
 }
 
 /* free up any keys used by the main thread */
 void
-bdb_locker_flush( DB_ENV *env )
+bdb_reader_flush( DB_ENV *env )
 {
 	void *data;
 	void *ctx = ldap_pvt_thread_pool_context();
 
 	if ( !ldap_pvt_thread_pool_getkey( ctx, env, &data, NULL ) ) {
 		ldap_pvt_thread_pool_setkey( ctx, env, NULL, 0, NULL, NULL );
-		bdb_locker_id_free( env, data );
+		bdb_reader_free( env, data );
 	}
 }
 
 int
-bdb_locker_id( Operation *op, DB_ENV *env, BDB_LOCKER *locker )
+bdb_reader_get( Operation *op, DB_ENV *env, DB_TXN **txn )
 {
 	int i, rc;
-	u_int32_t lockid;
 	void *data;
 	void *ctx;
 
-	if ( !env || !locker ) return -1;
+	if ( !env || !txn ) return -1;
 
 	/* If no op was provided, try to find the ctx anyway... */
 	if ( op ) {
@@ -1496,42 +1475,29 @@
 
 	/* Shouldn't happen unless we're single-threaded */
 	if ( !ctx ) {
-		*locker = 0;
+		*txn = NULL;
 		return 0;
 	}
 
 	if ( ldap_pvt_thread_pool_getkey( ctx, env, &data, NULL ) ) {
 		for ( i=0, rc=1; rc != 0 && i<4; i++ ) {
-			rc = XLOCK_ID( env, &lockid );
+			rc = TXN_BEGIN( env, NULL, txn, DB_READ_COMMITTED | DB_TXN_NOWAIT );
 			if (rc) ldap_pvt_thread_yield();
 		}
 		if ( rc != 0) {
 			return rc;
 		}
-#if DB_VERSION_FULL >= 0x04060012
-		{ BDB_LOCKER lptr;
-		__lock_getlocker( env->lk_handle, lockid, 0, &lptr );
-		data = lptr;
-		}
-#else
-		data = (void *)((long)lockid);
-#endif
+		data = *txn;
 		if ( ( rc = ldap_pvt_thread_pool_setkey( ctx, env,
-			data, bdb_locker_id_free, NULL, NULL ) ) ) {
-			XLOCK_ID_FREE( env, lockid );
-			Debug( LDAP_DEBUG_ANY, "bdb_locker_id: err %s(%d)\n",
+			data, bdb_reader_free, NULL, NULL ) ) ) {
+			TXN_ABORT( *txn );
+			Debug( LDAP_DEBUG_ANY, "bdb_reader_get: err %s(%d)\n",
 				db_strerror(rc), rc, 0 );
 
 			return rc;
 		}
 	} else {
-		lockid = (long)data;
+		*txn = data;
 	}
-#if DB_VERSION_FULL >= 0x04060012
-	*locker = data;
-#else
-	*locker = lockid;
-#endif
 	return 0;
 }
-#endif /* BDB_REUSE_LOCKERS */
Index: compare.c
===================================================================
RCS file: /repo/OpenLDAP/pkg/ldap/servers/slapd/back-bdb/compare.c,v
retrieving revision 1.57
retrieving revision 1.58
diff -u -r1.57 -r1.58
--- servers/slapd/back-bdb/compare.c	7 Jan 2008 23:20:10 -0000	1.57
+++ servers/slapd/back-bdb/compare.c	26 Aug 2008 23:45:35 -0000	1.58
@@ -30,10 +30,10 @@
 	Attribute	*a;
 	int		manageDSAit = get_manageDSAit( op );
 
-	BDB_LOCKER	locker;
+	DB_TXN		*rtxn;
 	DB_LOCK		lock;
 
-	rs->sr_err = LOCK_ID(bdb->bi_dbenv, &locker);
+	rs->sr_err = bdb_reader_get(op, bdb->bi_dbenv, &rtxn);
 	switch(rs->sr_err) {
 	case 0:
 		break;
@@ -44,8 +44,8 @@
 
 dn2entry_retry:
 	/* get entry */
-	rs->sr_err = bdb_dn2entry( op, NULL, &op->o_req_ndn, &ei, 1,
-		locker, &lock );
+	rs->sr_err = bdb_dn2entry( op, rtxn, &op->o_req_ndn, &ei, 1,
+		&lock );
 
 	switch( rs->sr_err ) {
 	case DB_NOTFOUND:
@@ -185,6 +185,5 @@
 		bdb_cache_return_entry_r( bdb, e, &lock );
 	}
 
-	LOCK_ID_FREE ( bdb->bi_dbenv, locker );
 	return rs->sr_err;
 }
Index: config.c
===================================================================
RCS file: /repo/OpenLDAP/pkg/ldap/servers/slapd/back-bdb/config.c,v
retrieving revision 1.107
retrieving revision 1.108
diff -u -r1.107 -r1.108
--- servers/slapd/back-bdb/config.c	2 Apr 2008 01:08:06 -0000	1.107
+++ servers/slapd/back-bdb/config.c	26 Aug 2008 23:45:35 -0000	1.108
@@ -202,7 +202,6 @@
 	DBT key, data;
 	DB_TXN *txn;
 	DB_LOCK lock;
-	BDB_LOCKER locker;
 	ID id, nid;
 	EntryInfo *ei;
 	int rc, getnext = 1;
@@ -231,7 +230,6 @@
 		rc = TXN_BEGIN( bdb->bi_dbenv, NULL, &txn, bdb->bi_db_opflags );
 		if ( rc ) 
 			break;
-		locker = TXN_ID( txn );
 		if ( getnext ) {
 			getnext = 0;
 			BDB_ID2DISK( id, &nid );
@@ -257,7 +255,7 @@
 		}
 
 		ei = NULL;
-		rc = bdb_cache_find_id( op, txn, id, &ei, 0, locker, &lock );
+		rc = bdb_cache_find_id( op, txn, id, &ei, 0, &lock );
 		if ( rc ) {
 			TXN_ABORT( txn );
 			if ( rc == DB_LOCK_DEADLOCK ) {
Index: delete.c
===================================================================
RCS file: /repo/OpenLDAP/pkg/ldap/servers/slapd/back-bdb/delete.c,v
retrieving revision 1.172
retrieving revision 1.173
diff -u -r1.172 -r1.173
--- servers/slapd/back-bdb/delete.c	1 May 2008 11:25:15 -0000	1.172
+++ servers/slapd/back-bdb/delete.c	26 Aug 2008 23:45:35 -0000	1.173
@@ -38,7 +38,6 @@
 	struct bdb_op_info opinfo = {0};
 	ID	eid;
 
-	BDB_LOCKER	locker = 0;
 	DB_LOCK		lock, plock;
 
 	int		num_retries = 0;
@@ -154,8 +153,6 @@
 		goto return_results;
 	}
 
-	locker = TXN_ID ( ltid );
-
 	opinfo.boi_oe.oe_key = bdb;
 	opinfo.boi_txn = ltid;
 	opinfo.boi_err = 0;
@@ -168,7 +165,7 @@
 
 	/* get entry */
 	rs->sr_err = bdb_dn2entry( op, ltid, &op->o_req_ndn, &ei, 1,
-		locker, &lock );
+		&lock );
 
 	switch( rs->sr_err ) {
 	case 0:
@@ -217,7 +214,7 @@
 		goto return_results;
 	}
 
-	rc = bdb_cache_find_id( op, ltid, eip->bei_id, &eip, 0, locker, &plock );
+	rc = bdb_cache_find_id( op, ltid, eip->bei_id, &eip, 0, &plock );
 	switch( rc ) {
 	case DB_LOCK_DEADLOCK:
 	case DB_LOCK_NOTGRANTED:
@@ -527,7 +524,7 @@
 		BDB_LOG_PRINTF( bdb->bi_dbenv, ltid, "slapd Cache delete %s(%d)",
 			e->e_nname.bv_val, e->e_id );
 
-		rc = bdb_cache_delete( bdb, e, locker, &lock );
+		rc = bdb_cache_delete( bdb, e, ltid, &lock );
 		switch( rc ) {
 		case DB_LOCK_DEADLOCK:
 		case DB_LOCK_NOTGRANTED:
Index: dn2entry.c
===================================================================
RCS file: /repo/OpenLDAP/pkg/ldap/servers/slapd/back-bdb/dn2entry.c,v
retrieving revision 1.35
retrieving revision 1.36
diff -u -r1.35 -r1.36
--- servers/slapd/back-bdb/dn2entry.c	7 Jan 2008 23:20:10 -0000	1.35
+++ servers/slapd/back-bdb/dn2entry.c	26 Aug 2008 23:45:35 -0000	1.36
@@ -34,7 +34,6 @@
 	struct berval *dn,
 	EntryInfo **e,
 	int matched,
-	BDB_LOCKER locker,
 	DB_LOCK *lock )
 {
 	EntryInfo *ei = NULL;
@@ -45,7 +44,7 @@
 
 	*e = NULL;
 
-	rc = bdb_cache_find_ndn( op, locker, dn, &ei );
+	rc = bdb_cache_find_ndn( op, tid, dn, &ei );
 	if ( rc ) {
 		if ( matched && rc == DB_NOTFOUND ) {
 			/* Set the return value, whether we have its entry
@@ -54,7 +53,7 @@
 			*e = ei;
 			if ( ei && ei->bei_id ) {
 				rc2 = bdb_cache_find_id( op, tid, ei->bei_id,
-					&ei, ID_LOCKED, locker, lock );
+					&ei, ID_LOCKED, lock );
 				if ( rc2 ) rc = rc2;
 			} else if ( ei ) {
 				bdb_cache_entryinfo_unlock( ei );
@@ -66,7 +65,7 @@
 		}
 	} else {
 		rc = bdb_cache_find_id( op, tid, ei->bei_id, &ei, ID_LOCKED,
-			locker, lock );
+			lock );
 		if ( rc == 0 ) {
 			*e = ei;
 		} else if ( matched && rc == DB_NOTFOUND ) {
@@ -74,7 +73,7 @@
 			if ( ei->bei_parent ) {
 				ei = ei->bei_parent;
 				rc2 = bdb_cache_find_id( op, tid, ei->bei_id, &ei, 0,
-					locker, lock );
+					lock );
 				if ( rc2 ) rc = rc2;
 			}
 			*e = ei;
Index: dn2id.c
===================================================================
RCS file: /repo/OpenLDAP/pkg/ldap/servers/slapd/back-bdb/dn2id.c,v
retrieving revision 1.156
retrieving revision 1.157
diff -u -r1.156 -r1.157
--- servers/slapd/back-bdb/dn2id.c	19 May 2008 14:19:59 -0000	1.156
+++ servers/slapd/back-bdb/dn2id.c	26 Aug 2008 23:45:35 -0000	1.157
@@ -27,13 +27,13 @@
 
 static int
 bdb_dn2id_lock( struct bdb_info *bdb, struct berval *dn,
-	int rw, BDB_LOCKER locker, DB_LOCK *lock )
+	int rw, DB_TXN *txn, DB_LOCK *lock )
 {
 	int       rc;
 	DBT       lockobj;
 	int       db_rw;
 
-	if (!locker)
+	if (!txn)
 		return 0;
 
 	if (rw)
@@ -44,7 +44,7 @@
 	lockobj.data = dn->bv_val;
 	lockobj.size = dn->bv_len;
 
-	rc = LOCK_GET(bdb->bi_dbenv, BDB_LOCKID(locker), DB_LOCK_NOWAIT,
+	rc = LOCK_GET(bdb->bi_dbenv, TXN_ID(txn), DB_LOCK_NOWAIT,
 					&lockobj, db_rw, lock);
 	return rc;
 }
@@ -193,7 +193,7 @@
 	ptr.bv_val[ptr.bv_len] = '\0';
 
 	/* We hold this lock until the TXN completes */
-	rc = bdb_dn2id_lock( bdb, &e->e_nname, 1, TXN_ID( txn ), &lock );
+	rc = bdb_dn2id_lock( bdb, &e->e_nname, 1, txn, &lock );
 	if ( rc ) goto done;
 
 	/* delete it */
@@ -277,7 +277,7 @@
 	Operation *op,
 	struct berval	*dn,
 	EntryInfo *ei,
-	BDB_LOCKER locker,
+	DB_TXN *txn,
 	DB_LOCK *lock )
 {
 	struct bdb_info *bdb = (struct bdb_info *) op->o_bd->be_private;
@@ -301,16 +301,12 @@
 	data.ulen = sizeof(ID);
 	data.flags = DB_DBT_USERMEM;
 
-	rc = db->cursor( db, NULL, &cursor, bdb->bi_db_opflags );
+	rc = db->cursor( db, txn, &cursor, bdb->bi_db_opflags );
 	if ( rc ) goto func_leave;
 
-	rc = bdb_dn2id_lock( bdb, dn, 0, locker, lock );
+	rc = bdb_dn2id_lock( bdb, dn, 0, txn, lock );
 	if ( rc ) goto nolock;
 
-	if ( locker ) {
-		CURSOR_SETLOCKER(cursor, locker);
-	}
-
 	/* fetch it */
 	rc = cursor->c_get( cursor, &key, &data, DB_SET );
 
@@ -379,7 +375,7 @@
 int
 bdb_dn2idl(
 	Operation *op,
-	BDB_LOCKER locker,
+	DB_TXN *txn,
 	struct berval *ndn,
 	EntryInfo *ei,
 	ID *ids,
@@ -412,7 +408,7 @@
 	AC_MEMCPY( &((char *)key.data)[1], ndn->bv_val, key.size - 1 );
 
 	BDB_IDL_ZERO( ids );
-	rc = bdb_idl_fetch_key( op->o_bd, db, locker, &key, ids, NULL, 0 );
+	rc = bdb_idl_fetch_key( op->o_bd, db, txn, &key, ids, NULL, 0 );
 
 	if( rc != 0 ) {
 		Debug( LDAP_DEBUG_TRACE,
@@ -677,7 +673,7 @@
 	if ( rc ) goto func_leave;
 
 	/* We hold this lock until the TXN completes */
-	rc = bdb_dn2id_lock( bdb, &e->e_nname, 1, TXN_ID( txn ), &lock );
+	rc = bdb_dn2id_lock( bdb, &e->e_nname, 1, txn, &lock );
 	if ( rc ) goto nolock;
 
 	/* Delete our ID from the parent's list */
@@ -731,7 +727,7 @@
 	Operation	*op,
 	struct berval	*in,
 	EntryInfo	*ei,
-	BDB_LOCKER locker,
+	DB_TXN *txn,
 	DB_LOCK *lock )
 {
 	struct bdb_info *bdb = (struct bdb_info *) op->o_bd->be_private;
@@ -763,11 +759,8 @@
 	data.dlen = data.ulen;
 	data.flags = DB_DBT_USERMEM | DB_DBT_PARTIAL;
 
-	rc = db->cursor( db, NULL, &cursor, bdb->bi_db_opflags );
+	rc = db->cursor( db, txn, &cursor, bdb->bi_db_opflags );
 	if ( rc ) return rc;
-	if ( locker ) {
-		CURSOR_SETLOCKER( cursor, locker );
-	}
 
 	d = op->o_tmpalloc( data.size * 3, op->o_tmpmemctx );
 	d->nrdnlen[1] = nrlen & 0xff;
@@ -778,7 +771,7 @@
 	*ptr = '\0';
 	data.data = d;
 
-	rc = bdb_dn2id_lock( bdb, in, 0, locker, lock );
+	rc = bdb_dn2id_lock( bdb, in, 0, txn, lock );
 	if ( rc ) goto func_leave;
 
 	rc = cursor->c_get( cursor, &key, &data, DB_GET_BOTH_RANGE );
@@ -820,7 +813,7 @@
 int
 hdb_dn2id_parent(
 	Operation *op,
-	BDB_LOCKER	locker,
+	DB_TXN *txn,
 	EntryInfo *ei,
 	ID *idp )
 {
@@ -843,11 +836,8 @@
 	DBTzero(&data);
 	data.flags = DB_DBT_USERMEM;
 
-	rc = db->cursor( db, NULL, &cursor, bdb->bi_db_opflags );
+	rc = db->cursor( db, txn, &cursor, bdb->bi_db_opflags );
 	if ( rc ) return rc;
-	if ( locker ) {
-		CURSOR_SETLOCKER(cursor, locker);
-	}
 
 	data.ulen = sizeof(diskNode) + (SLAP_LDAPDN_MAXLEN * 2);
 	d = op->o_tmpalloc( data.ulen, op->o_tmpmemctx );
@@ -941,7 +931,7 @@
 struct dn2id_cookie {
 	struct bdb_info *bdb;
 	Operation *op;
-	BDB_LOCKER locker;
+	DB_TXN *txn;
 	EntryInfo *ei;
 	ID *ids;
 	ID *tmp;
@@ -1176,7 +1166,7 @@
 int
 hdb_dn2idl(
 	Operation	*op,
-	BDB_LOCKER locker,
+	DB_TXN *txn,
 	struct berval *ndn,
 	EntryInfo	*ei,
 	ID *ids,
@@ -1209,7 +1199,7 @@
 	cx.tmp = stack;
 	cx.buf = stack + BDB_IDL_UM_SIZE;
 	cx.op = op;
-	cx.locker = locker;
+	cx.txn = txn;
 	cx.need_sort = 0;
 	cx.depth = 0;
 
Index: filterindex.c
===================================================================
RCS file: /repo/OpenLDAP/pkg/ldap/servers/slapd/back-bdb/filterindex.c,v
retrieving revision 1.75
retrieving revision 1.76
diff -u -r1.75 -r1.76
--- servers/slapd/back-bdb/filterindex.c	7 Jan 2008 23:20:10 -0000	1.75
+++ servers/slapd/back-bdb/filterindex.c	26 Aug 2008 23:45:35 -0000	1.76
@@ -27,39 +27,39 @@
 
 static int presence_candidates(
 	Operation *op,
-	BDB_LOCKER locker,
+	DB_TXN *rtxn,
 	AttributeDescription *desc,
 	ID *ids );
 
 static int equality_candidates(
 	Operation *op,
-	BDB_LOCKER locker,
+	DB_TXN *rtxn,
 	AttributeAssertion *ava,
 	ID *ids,
 	ID *tmp );
 static int inequality_candidates(
 	Operation *op,
-	BDB_LOCKER locker,
+	DB_TXN *rtxn,
 	AttributeAssertion *ava,
 	ID *ids,
 	ID *tmp,
 	int gtorlt );
 static int approx_candidates(
 	Operation *op,
-	BDB_LOCKER locker,
+	DB_TXN *rtxn,
 	AttributeAssertion *ava,
 	ID *ids,
 	ID *tmp );
 static int substring_candidates(
 	Operation *op,
-	BDB_LOCKER locker,
+	DB_TXN *rtxn,
 	SubstringsAssertion *sub,
 	ID *ids,
 	ID *tmp );
 
 static int list_candidates(
 	Operation *op,
-	BDB_LOCKER locker,
+	DB_TXN *rtxn,
 	Filter *flist,
 	int ftype,
 	ID *ids,
@@ -69,7 +69,7 @@
 static int
 ext_candidates(
         Operation *op,
-		BDB_LOCKER locker,
+		DB_TXN *rtxn,
         MatchingRuleAssertion *mra,
         ID *ids,
         ID *tmp,
@@ -79,7 +79,7 @@
 static int
 comp_candidates (
 	Operation *op,
-	BDB_LOCKER locker,
+	DB_TXN *rtxn,
 	MatchingRuleAssertion *mra,
 	ComponentFilter *f,
 	ID *ids,
@@ -89,7 +89,7 @@
 static int
 ava_comp_candidates (
 		Operation *op,
-		BDB_LOCKER locker,
+		DB_TXN *rtxn,
 		AttributeAssertion *ava,
 		AttributeAliasing *aa,
 		ID *ids,
@@ -100,7 +100,7 @@
 int
 bdb_filter_candidates(
 	Operation *op,
-	BDB_LOCKER locker,
+	DB_TXN *rtxn,
 	Filter	*f,
 	ID *ids,
 	ID *tmp,
@@ -139,30 +139,30 @@
 		break;
 	case LDAP_FILTER_PRESENT:
 		Debug( LDAP_DEBUG_FILTER, "\tPRESENT\n", 0, 0, 0 );
-		rc = presence_candidates( op, locker, f->f_desc, ids );
+		rc = presence_candidates( op, rtxn, f->f_desc, ids );
 		break;
 
 	case LDAP_FILTER_EQUALITY:
 		Debug( LDAP_DEBUG_FILTER, "\tEQUALITY\n", 0, 0, 0 );
 #ifdef LDAP_COMP_MATCH
 		if ( is_aliased_attribute && ( aa = is_aliased_attribute ( f->f_ava->aa_desc ) ) ) {
-			rc = ava_comp_candidates ( op, locker, f->f_ava, aa, ids, tmp, stack );
+			rc = ava_comp_candidates ( op, rtxn, f->f_ava, aa, ids, tmp, stack );
 		}
 		else
 #endif
 		{
-			rc = equality_candidates( op, locker, f->f_ava, ids, tmp );
+			rc = equality_candidates( op, rtxn, f->f_ava, ids, tmp );
 		}
 		break;
 
 	case LDAP_FILTER_APPROX:
 		Debug( LDAP_DEBUG_FILTER, "\tAPPROX\n", 0, 0, 0 );
-		rc = approx_candidates( op, locker, f->f_ava, ids, tmp );
+		rc = approx_candidates( op, rtxn, f->f_ava, ids, tmp );
 		break;
 
 	case LDAP_FILTER_SUBSTRINGS:
 		Debug( LDAP_DEBUG_FILTER, "\tSUBSTRINGS\n", 0, 0, 0 );
-		rc = substring_candidates( op, locker, f->f_sub, ids, tmp );
+		rc = substring_candidates( op, rtxn, f->f_sub, ids, tmp );
 		break;
 
 	case LDAP_FILTER_GE:
@@ -170,9 +170,9 @@
 		Debug( LDAP_DEBUG_FILTER, "\tGE\n", 0, 0, 0 );
 		if( f->f_ava->aa_desc->ad_type->sat_ordering &&
 			( f->f_ava->aa_desc->ad_type->sat_ordering->smr_usage & SLAP_MR_ORDERED_INDEX ) )
-			rc = inequality_candidates( op, locker, f->f_ava, ids, tmp, LDAP_FILTER_GE );
+			rc = inequality_candidates( op, rtxn, f->f_ava, ids, tmp, LDAP_FILTER_GE );
 		else
-			rc = presence_candidates( op, locker, f->f_ava->aa_desc, ids );
+			rc = presence_candidates( op, rtxn, f->f_ava->aa_desc, ids );
 		break;
 
 	case LDAP_FILTER_LE:
@@ -180,9 +180,9 @@
 		Debug( LDAP_DEBUG_FILTER, "\tLE\n", 0, 0, 0 );
 		if( f->f_ava->aa_desc->ad_type->sat_ordering &&
 			( f->f_ava->aa_desc->ad_type->sat_ordering->smr_usage & SLAP_MR_ORDERED_INDEX ) )
-			rc = inequality_candidates( op, locker, f->f_ava, ids, tmp, LDAP_FILTER_LE );
+			rc = inequality_candidates( op, rtxn, f->f_ava, ids, tmp, LDAP_FILTER_LE );
 		else
-			rc = presence_candidates( op, locker, f->f_ava->aa_desc, ids );
+			rc = presence_candidates( op, rtxn, f->f_ava->aa_desc, ids );
 		break;
 
 	case LDAP_FILTER_NOT:
@@ -195,18 +195,18 @@
 
 	case LDAP_FILTER_AND:
 		Debug( LDAP_DEBUG_FILTER, "\tAND\n", 0, 0, 0 );
-		rc = list_candidates( op, locker, 
+		rc = list_candidates( op, rtxn, 
 			f->f_and, LDAP_FILTER_AND, ids, tmp, stack );
 		break;
 
 	case LDAP_FILTER_OR:
 		Debug( LDAP_DEBUG_FILTER, "\tOR\n", 0, 0, 0 );
-		rc = list_candidates( op, locker,
+		rc = list_candidates( op, rtxn,
 			f->f_or, LDAP_FILTER_OR, ids, tmp, stack );
 		break;
 	case LDAP_FILTER_EXT:
                 Debug( LDAP_DEBUG_FILTER, "\tEXT\n", 0, 0, 0 );
-                rc = ext_candidates( op, locker, f->f_mra, ids, tmp, stack );
+                rc = ext_candidates( op, rtxn, f->f_mra, ids, tmp, stack );
                 break;
 	default:
 		Debug( LDAP_DEBUG_FILTER, "\tUNKNOWN %lu\n",
@@ -231,7 +231,7 @@
 static int
 comp_list_candidates(
 	Operation *op,
-	BDB_LOCKER locker,
+	DB_TXN *rtxn,
 	MatchingRuleAssertion* mra,
 	ComponentFilter	*flist,
 	int	ftype,
@@ -250,7 +250,7 @@
 			continue;
 		}
 		BDB_IDL_ZERO( save );
-		rc = comp_candidates( op, locker, mra, f, save, tmp, save+BDB_IDL_UM_SIZE );
+		rc = comp_candidates( op, rtxn, mra, f, save, tmp, save+BDB_IDL_UM_SIZE );
 
 		if ( rc != 0 ) {
 			if ( ftype == LDAP_COMP_FILTER_AND ) {
@@ -296,7 +296,7 @@
 static int
 comp_equality_candidates (
         Operation *op,
-	BDB_LOCKER locker,
+	DB_TXN *rtxn,
         MatchingRuleAssertion *mra,
 	ComponentAssertion *ca,
         ID *ids,
@@ -370,7 +370,7 @@
                 return 0;
         }
         for ( i= 0; keys[i].bv_val != NULL; i++ ) {
-                rc = bdb_key_read( op->o_bd, db, locker, &keys[i], tmp, NULL, 0 );
+                rc = bdb_key_read( op->o_bd, db, rtxn, &keys[i], tmp, NULL, 0 );
 
                 if( rc == DB_NOTFOUND ) {
                         BDB_IDL_ZERO( ids );
@@ -407,7 +407,7 @@
 static int
 ava_comp_candidates (
 	Operation *op,
-	BDB_LOCKER locker,
+	DB_TXN *rtxn,
 	AttributeAssertion *ava,
 	AttributeAliasing *aa,
 	ID *ids,
@@ -425,13 +425,13 @@
 	mra.ma_desc = aa->aa_aliased_ad;
 	mra.ma_rule = ava->aa_desc->ad_type->sat_equality;
 	
-	return comp_candidates ( op, locker, &mra, ava->aa_cf, ids, tmp, stack );
+	return comp_candidates ( op, rtxn, &mra, ava->aa_cf, ids, tmp, stack );
 }
 
 static int
 comp_candidates (
 	Operation *op,
-	BDB_LOCKER locker,
+	DB_TXN *rtxn,
 	MatchingRuleAssertion *mra,
 	ComponentFilter *f,
 	ID *ids,
@@ -448,10 +448,10 @@
 		rc = f->cf_result;
 		break;
 	case LDAP_COMP_FILTER_AND:
-		rc = comp_list_candidates( op, locker, mra, f->cf_and, LDAP_COMP_FILTER_AND, ids, tmp, stack );
+		rc = comp_list_candidates( op, rtxn, mra, f->cf_and, LDAP_COMP_FILTER_AND, ids, tmp, stack );
 		break;
 	case LDAP_COMP_FILTER_OR:
-		rc = comp_list_candidates( op, locker, mra, f->cf_or, LDAP_COMP_FILTER_OR, ids, tmp, stack );
+		rc = comp_list_candidates( op, rtxn, mra, f->cf_or, LDAP_COMP_FILTER_OR, ids, tmp, stack );
 		break;
 	case LDAP_COMP_FILTER_NOT:
 		/* No component indexing supported for NOT filter */
@@ -463,7 +463,7 @@
 		rc = LDAP_PROTOCOL_ERROR;
 		break;
 	case LDAP_COMP_FILTER_ITEM:
-		rc = comp_equality_candidates( op, locker, mra, f->cf_ca, ids, tmp, stack );
+		rc = comp_equality_candidates( op, rtxn, mra, f->cf_ca, ids, tmp, stack );
 		break;
 	default:
 		{
@@ -480,7 +480,7 @@
 static int
 ext_candidates(
         Operation *op,
-		BDB_LOCKER locker,
+		DB_TXN *rtxn,
         MatchingRuleAssertion *mra,
         ID *ids,
         ID *tmp,
@@ -494,7 +494,7 @@
 	 * Indexing for an extensible filter is not supported yet
 	 */
 	if ( mra->ma_cf ) {
-		return comp_candidates ( op, locker, mra, mra->ma_cf, ids, tmp, stack);
+		return comp_candidates ( op, rtxn, mra, mra->ma_cf, ids, tmp, stack);
 	}
 #endif
 	if ( mra->ma_desc == slap_schema.si_ad_entryDN ) {
@@ -504,7 +504,7 @@
 		BDB_IDL_ZERO( ids );
 		if ( mra->ma_rule == slap_schema.si_mr_distinguishedNameMatch ) {
 			ei = NULL;
-			rc = bdb_cache_find_ndn( op, locker, &mra->ma_value, &ei );
+			rc = bdb_cache_find_ndn( op, rtxn, &mra->ma_value, &ei );
 			if ( rc == LDAP_SUCCESS )
 				bdb_idl_insert( ids, ei->bei_id );
 			if ( ei )
@@ -518,7 +518,7 @@
 				struct berval pdn;
 				ei = NULL;
 				dnParent( &mra->ma_value, &pdn );
-				bdb_cache_find_ndn( op, locker, &pdn, &ei );
+				bdb_cache_find_ndn( op, rtxn, &pdn, &ei );
 				if ( ei ) {
 					bdb_cache_entryinfo_unlock( ei );
 					while ( ei && ei->bei_id ) {
@@ -538,13 +538,13 @@
 				scope = LDAP_SCOPE_BASE;
 			if ( scope > LDAP_SCOPE_BASE ) {
 				ei = NULL;
-				rc = bdb_cache_find_ndn( op, locker, &mra->ma_value, &ei );
+				rc = bdb_cache_find_ndn( op, rtxn, &mra->ma_value, &ei );
 				if ( ei )
 					bdb_cache_entryinfo_unlock( ei );
 				if ( rc == LDAP_SUCCESS ) {
 					int sc = op->ors_scope;
 					op->ors_scope = scope;
-					rc = bdb_dn2idl( op, locker, &mra->ma_value, ei, ids,
+					rc = bdb_dn2idl( op, rtxn, &mra->ma_value, ei, ids,
 						stack );
 					op->ors_scope = sc;
 				}
@@ -560,7 +560,7 @@
 static int
 list_candidates(
 	Operation *op,
-	BDB_LOCKER locker,
+	DB_TXN *rtxn,
 	Filter	*flist,
 	int		ftype,
 	ID *ids,
@@ -578,7 +578,7 @@
 			continue;
 		}
 		BDB_IDL_ZERO( save );
-		rc = bdb_filter_candidates( op, locker, f, save, tmp,
+		rc = bdb_filter_candidates( op, rtxn, f, save, tmp,
 			save+BDB_IDL_UM_SIZE );
 
 		if ( rc != 0 ) {
@@ -626,7 +626,7 @@
 static int
 presence_candidates(
 	Operation *op,
-	BDB_LOCKER locker,
+	DB_TXN *rtxn,
 	AttributeDescription *desc,
 	ID *ids )
 {
@@ -671,7 +671,7 @@
 		return -1;
 	}
 
-	rc = bdb_key_read( op->o_bd, db, locker, &prefix, ids, NULL, 0 );
+	rc = bdb_key_read( op->o_bd, db, rtxn, &prefix, ids, NULL, 0 );
 
 	if( rc == DB_NOTFOUND ) {
 		BDB_IDL_ZERO( ids );
@@ -697,7 +697,7 @@
 static int
 equality_candidates(
 	Operation *op,
-	BDB_LOCKER locker,
+	DB_TXN *rtxn,
 	AttributeAssertion *ava,
 	ID *ids,
 	ID *tmp )
@@ -768,7 +768,7 @@
 	}
 
 	for ( i= 0; keys[i].bv_val != NULL; i++ ) {
-		rc = bdb_key_read( op->o_bd, db, locker, &keys[i], tmp, NULL, 0 );
+		rc = bdb_key_read( op->o_bd, db, rtxn, &keys[i], tmp, NULL, 0 );
 
 		if( rc == DB_NOTFOUND ) {
 			BDB_IDL_ZERO( ids );
@@ -814,7 +814,7 @@
 static int
 approx_candidates(
 	Operation *op,
-	BDB_LOCKER locker,
+	DB_TXN *rtxn,
 	AttributeAssertion *ava,
 	ID *ids,
 	ID *tmp )
@@ -890,7 +890,7 @@
 	}
 
 	for ( i= 0; keys[i].bv_val != NULL; i++ ) {
-		rc = bdb_key_read( op->o_bd, db, locker, &keys[i], tmp, NULL, 0 );
+		rc = bdb_key_read( op->o_bd, db, rtxn, &keys[i], tmp, NULL, 0 );
 
 		if( rc == DB_NOTFOUND ) {
 			BDB_IDL_ZERO( ids );
@@ -934,7 +934,7 @@
 static int
 substring_candidates(
 	Operation *op,
-	BDB_LOCKER locker,
+	DB_TXN *rtxn,
 	SubstringsAssertion	*sub,
 	ID *ids,
 	ID *tmp )
@@ -1006,7 +1006,7 @@
 	}
 
 	for ( i= 0; keys[i].bv_val != NULL; i++ ) {
-		rc = bdb_key_read( op->o_bd, db, locker, &keys[i], tmp, NULL, 0 );
+		rc = bdb_key_read( op->o_bd, db, rtxn, &keys[i], tmp, NULL, 0 );
 
 		if( rc == DB_NOTFOUND ) {
 			BDB_IDL_ZERO( ids );
@@ -1050,7 +1050,7 @@
 static int
 inequality_candidates(
 	Operation *op,
-	BDB_LOCKER locker,
+	DB_TXN *rtxn,
 	AttributeAssertion *ava,
 	ID *ids,
 	ID *tmp,
@@ -1123,7 +1123,7 @@
 
 	BDB_IDL_ZERO( ids );
 	while(1) {
-		rc = bdb_key_read( op->o_bd, db, locker, &keys[0], tmp, &cursor, gtorlt );
+		rc = bdb_key_read( op->o_bd, db, rtxn, &keys[0], tmp, &cursor, gtorlt );
 
 		if( rc == DB_NOTFOUND ) {
 			rc = 0;
Index: id2entry.c
===================================================================
RCS file: /repo/OpenLDAP/pkg/ldap/servers/slapd/back-bdb/id2entry.c,v
retrieving revision 1.86
retrieving revision 1.87
diff -u -r1.86 -r1.87
--- servers/slapd/back-bdb/id2entry.c	9 Aug 2008 14:04:55 -0000	1.86
+++ servers/slapd/back-bdb/id2entry.c	26 Aug 2008 23:45:35 -0000	1.87
@@ -93,7 +93,6 @@
 int bdb_id2entry(
 	BackendDB *be,
 	DB_TXN *tid,
-	BDB_LOCKER locker,
 	ID id,
 	Entry **e )
 {
@@ -120,11 +119,6 @@
 	rc = db->cursor( db, tid, &cursor, bdb->bi_db_opflags );
 	if ( rc ) return rc;
 
-	/* Use our own locker if needed */
-	if ( !tid && locker ) {
-		CURSOR_SETLOCKER( cursor, locker );
-	}
-
 	/* Get the nattrs / nvals counts first */
 	data.ulen = data.dlen = sizeof(buf);
 	data.data = buf;
@@ -322,9 +316,7 @@
 	int	rc;
 	const char *at_name = at ? at->ad_cname.bv_val : "(null)";
 
-	BDB_LOCKER	locker = 0;
 	DB_LOCK		lock;
-	int		free_lock_id = 0;
 
 	Debug( LDAP_DEBUG_ARGS,
 		"=> bdb_entry_get: ndn: \"%s\"\n", ndn->bv_val, 0, 0 ); 
@@ -342,11 +334,8 @@
 			txn = boi->boi_txn;
 	}
 
-	if ( txn != NULL ) {
-		locker = TXN_ID ( txn );
-	} else {
-		rc = LOCK_ID ( bdb->bi_dbenv, &locker );
-		free_lock_id = 1;
+	if ( !txn ) {
+		rc = bdb_reader_get( op, bdb->bi_dbenv, &txn );
 		switch(rc) {
 		case 0:
 			break;
@@ -357,7 +346,7 @@
 
 dn2entry_retry:
 	/* can we find entry */
-	rc = bdb_dn2entry( op, txn, ndn, &ei, 0, locker, &lock );
+	rc = bdb_dn2entry( op, txn, ndn, &ei, 0, &lock );
 	switch( rc ) {
 	case DB_NOTFOUND:
 	case 0:
@@ -373,9 +362,6 @@
 		goto dn2entry_retry;
 	default:
 		if ( boi ) boi->boi_err = rc;
-		if ( free_lock_id ) {
-			LOCK_ID_FREE( bdb->bi_dbenv, locker );
-		}
 		return (rc != LDAP_BUSY) ? LDAP_OTHER : LDAP_BUSY;
 	}
 	if (ei) e = ei->bei_e;
@@ -383,9 +369,6 @@
 		Debug( LDAP_DEBUG_ACL,
 			"=> bdb_entry_get: cannot find entry: \"%s\"\n",
 				ndn->bv_val, 0, 0 ); 
-		if ( free_lock_id ) {
-			LOCK_ID_FREE( bdb->bi_dbenv, locker );
-		}
 		return LDAP_NO_SUCH_OBJECT; 
 	}
 	
@@ -444,10 +427,6 @@
 		}
 	}
 
-	if ( free_lock_id ) {
-		LOCK_ID_FREE( bdb->bi_dbenv, locker );
-	}
-
 	Debug( LDAP_DEBUG_TRACE,
 		"bdb_entry_get: rc=%d\n",
 		rc, 0, 0 ); 
Index: idl.c
===================================================================
RCS file: /repo/OpenLDAP/pkg/ldap/servers/slapd/back-bdb/idl.c,v
retrieving revision 1.134
retrieving revision 1.135
diff -u -r1.134 -r1.135
--- servers/slapd/back-bdb/idl.c	7 Jan 2008 23:20:10 -0000	1.134
+++ servers/slapd/back-bdb/idl.c	26 Aug 2008 23:45:35 -0000	1.135
@@ -502,7 +502,7 @@
 bdb_idl_fetch_key(
 	BackendDB	*be,
 	DB			*db,
-	BDB_LOCKER locker,
+	DB_TXN		*txn,
 	DBT			*key,
 	ID			*ids,
 	DBC                     **saved_cursor,
@@ -575,13 +575,12 @@
 
 	/* If we're not reusing an existing cursor, get a new one */
 	if( opflag != DB_NEXT ) {
-		rc = db->cursor( db, NULL, &cursor, bdb->bi_db_opflags );
+		rc = db->cursor( db, txn, &cursor, bdb->bi_db_opflags );
 		if( rc != 0 ) {
 			Debug( LDAP_DEBUG_ANY, "=> bdb_idl_fetch_key: "
 				"cursor failed: %s (%d)\n", db_strerror(rc), rc, 0 );
 			return rc;
 		}
-		CURSOR_SETLOCKER( cursor, locker );
 	} else {
 		cursor = *saved_cursor;
 	}
Index: init.c
===================================================================
RCS file: /repo/OpenLDAP/pkg/ldap/servers/slapd/back-bdb/init.c,v
retrieving revision 1.291
retrieving revision 1.293
diff -u -r1.291 -r1.293
--- servers/slapd/back-bdb/init.c	10 Jan 2008 23:44:12 -0000	1.291
+++ servers/slapd/back-bdb/init.c	27 Aug 2008 20:28:16 -0000	1.293
@@ -61,7 +61,7 @@
 
 	/* DBEnv parameters */
 	bdb->bi_dbenv_home = ch_strdup( SLAPD_DEFAULT_DB_DIR );
-	bdb->bi_dbenv_xflags = 0;
+	bdb->bi_dbenv_xflags = DB_TIME_NOTGRANTED;
 	bdb->bi_dbenv_mode = SLAPD_DEFAULT_DB_MODE;
 
 	bdb->bi_cache.c_maxsize = DEFAULT_CACHE_SIZE;
@@ -503,13 +503,7 @@
 	}
 
 	if ( !quick ) {
-#if DB_VERSION_FULL >= 0x04060012
-		u_int32_t lid;
-		XLOCK_ID(bdb->bi_dbenv, &lid);
-		__lock_getlocker(bdb->bi_dbenv->lk_handle, lid, 0, &bdb->bi_cache.c_locker);
-#else
-		XLOCK_ID(bdb->bi_dbenv, &bdb->bi_cache.c_locker);
-#endif
+		TXN_BEGIN(bdb->bi_dbenv, NULL, &bdb->bi_cache.c_txn, DB_READ_COMMITTED | DB_TXN_NOWAIT);
 	}
 
 	entry_prealloc( bdb->bi_cache.c_maxsize );
@@ -517,7 +511,7 @@
 
 	/* setup for empty-DN contexts */
 	if ( BER_BVISEMPTY( &be->be_nsuffix[0] )) {
-		rc = bdb_id2entry( be, NULL, 0, 0, &e );
+		rc = bdb_id2entry( be, NULL, 0, &e );
 	}
 	if ( !e ) {
 		e = entry_alloc();
@@ -600,17 +594,12 @@
 	/* close db environment */
 	if( bdb->bi_dbenv ) {
 		/* Free cache locker if we enabled locking */
-		if ( !( slapMode & SLAP_TOOL_QUICK ) && bdb->bi_cache.c_locker ) {
-#if DB_VERSION_FULL >= 0x04060012
-			XLOCK_ID_FREE(bdb->bi_dbenv, bdb->bi_cache.c_locker->id);
-#else
-			XLOCK_ID_FREE(bdb->bi_dbenv, bdb->bi_cache.c_locker);
-#endif
-			bdb->bi_cache.c_locker = 0;
+		if ( !( slapMode & SLAP_TOOL_QUICK ) && bdb->bi_cache.c_txn ) {
+			TXN_ABORT( bdb->bi_cache.c_txn );
+			bdb->bi_cache.c_txn = NULL;
 		}
-#ifdef BDB_REUSE_LOCKERS
-		bdb_locker_flush( bdb->bi_dbenv );
-#endif
+		bdb_reader_flush( bdb->bi_dbenv );
+
 		/* force a checkpoint, but not if we were ReadOnly,
 		 * and not in Quick mode since there are no transactions there.
 		 */
@@ -745,9 +734,10 @@
 	db_env_set_func_free( ber_memfree );
 	db_env_set_func_malloc( (db_malloc *)ber_memalloc );
 	db_env_set_func_realloc( (db_realloc *)ber_memrealloc );
-#ifndef NO_THREAD
+#if !defined(NO_THREAD) && DB_VERSION_FULL <= 0x04070000
 	/* This is a no-op on a NO_THREAD build. Leave the default
 	 * alone so that BDB will sleep on interprocess conflicts.
+	 * Don't bother on BDB 4.7...
 	 */
 	db_env_set_func_yield( ldap_pvt_thread_yield );
 #endif
Index: key.c
===================================================================
RCS file: /repo/OpenLDAP/pkg/ldap/servers/slapd/back-bdb/key.c,v
retrieving revision 1.24
retrieving revision 1.25
diff -u -r1.24 -r1.25
--- servers/slapd/back-bdb/key.c	7 Jan 2008 23:20:10 -0000	1.24
+++ servers/slapd/back-bdb/key.c	26 Aug 2008 23:45:35 -0000	1.25
@@ -30,7 +30,7 @@
 bdb_key_read(
 	Backend	*be,
 	DB *db,
-	BDB_LOCKER locker,
+	DB_TXN *txn,
 	struct berval *k,
 	ID *ids,
 	DBC **saved_cursor,
@@ -47,7 +47,7 @@
 	key.ulen = key.size;
 	key.flags = DB_DBT_USERMEM;
 
-	rc = bdb_idl_fetch_key( be, db, locker, &key, ids, saved_cursor, get_flag );
+	rc = bdb_idl_fetch_key( be, db, txn, &key, ids, saved_cursor, get_flag );
 
 	if( rc != LDAP_SUCCESS ) {
 		Debug( LDAP_DEBUG_TRACE, "<= bdb_index_read: failed (%d)\n",
Index: modify.c
===================================================================
RCS file: /repo/OpenLDAP/pkg/ldap/servers/slapd/back-bdb/modify.c,v
retrieving revision 1.176
retrieving revision 1.177
diff -u -r1.176 -r1.177
--- servers/slapd/back-bdb/modify.c	1 May 2008 11:25:15 -0000	1.176
+++ servers/slapd/back-bdb/modify.c	26 Aug 2008 23:45:35 -0000	1.177
@@ -334,7 +334,6 @@
 	Entry		dummy = {0};
 	int			fakeroot = 0;
 
-	BDB_LOCKER	locker = 0;
 	DB_LOCK		lock;
 
 	int		num_retries = 0;
@@ -438,8 +437,6 @@
 		goto return_results;
 	}
 
-	locker = TXN_ID ( ltid );
-
 	opinfo.boi_oe.oe_key = bdb;
 	opinfo.boi_txn = ltid;
 	opinfo.boi_err = 0;
@@ -448,7 +445,7 @@
 
 	/* get entry or ancestor */
 	rs->sr_err = bdb_dn2entry( op, ltid, &op->o_req_ndn, &ei, 1,
-		locker, &lock );
+		&lock );
 
 	if ( rs->sr_err != 0 ) {
 		Debug( LDAP_DEBUG_TRACE,
@@ -655,7 +652,7 @@
 			attrs_free( dummy.e_attrs );
 
 		} else {
-			rc = bdb_cache_modify( bdb, e, dummy.e_attrs, locker, &lock );
+			rc = bdb_cache_modify( bdb, e, dummy.e_attrs, ltid, &lock );
 			switch( rc ) {
 			case DB_LOCK_DEADLOCK:
 			case DB_LOCK_NOTGRANTED:
Index: modrdn.c
===================================================================
RCS file: /repo/OpenLDAP/pkg/ldap/servers/slapd/back-bdb/modrdn.c,v
retrieving revision 1.200
retrieving revision 1.201
diff -u -r1.200 -r1.201
--- servers/slapd/back-bdb/modrdn.c	1 May 2008 11:25:15 -0000	1.200
+++ servers/slapd/back-bdb/modrdn.c	26 Aug 2008 23:45:35 -0000	1.201
@@ -46,7 +46,6 @@
 
 	int		manageDSAit = get_manageDSAit( op );
 
-	BDB_LOCKER	locker = 0;
 	DB_LOCK		lock, plock, nplock;
 
 	int		num_retries = 0;
@@ -164,8 +163,6 @@
 		goto return_results;
 	}
 
-	locker = TXN_ID ( ltid );
-
 	opinfo.boi_oe.oe_key = bdb;
 	opinfo.boi_txn = ltid;
 	opinfo.boi_err = 0;
@@ -174,7 +171,7 @@
 
 	/* get entry */
 	rs->sr_err = bdb_dn2entry( op, ltid, &op->o_req_ndn, &ei, 1,
-		locker, &lock );
+		&lock );
 
 	switch( rs->sr_err ) {
 	case 0:
@@ -309,7 +306,7 @@
 		 * children.
 		 */
 		rs->sr_err = bdb_cache_find_id( op, ltid,
-			eip->bei_id, &eip, 0, locker, &plock );
+			eip->bei_id, &eip, 0, &plock );
 
 		switch( rs->sr_err ) {
 		case 0:
@@ -418,7 +415,7 @@
 			/* Get Entry with dn=newSuperior. Does newSuperior exist? */
 
 			rs->sr_err = bdb_dn2entry( op, ltid, np_ndn,
-				&neip, 0, locker, &nplock );
+				&neip, 0, &nplock );
 
 			switch( rs->sr_err ) {
 			case 0: np = neip->bei_e;
@@ -551,7 +548,7 @@
 
 	/* Shortcut the search */
 	nei = neip ? neip : eip;
-	rs->sr_err = bdb_cache_find_ndn ( op, locker, &new_ndn, &nei );
+	rs->sr_err = bdb_cache_find_ndn ( op, ltid, &new_ndn, &nei );
 	if ( nei ) bdb_cache_entryinfo_unlock( nei );
 	switch( rs->sr_err ) {
 	case DB_LOCK_DEADLOCK:
@@ -747,7 +744,7 @@
 
 	} else {
 		rc = bdb_cache_modrdn( bdb, e, &op->orr_nnewrdn, &dummy, neip,
-			locker, &lock );
+			ltid, &lock );
 		switch( rc ) {
 		case DB_LOCK_DEADLOCK:
 		case DB_LOCK_NOTGRANTED:
Index: proto-bdb.h
===================================================================
RCS file: /repo/OpenLDAP/pkg/ldap/servers/slapd/back-bdb/proto-bdb.h,v
retrieving revision 1.159
retrieving revision 1.160
diff -u -r1.159 -r1.160
--- servers/slapd/back-bdb/proto-bdb.h	9 Feb 2008 23:56:44 -0000	1.159
+++ servers/slapd/back-bdb/proto-bdb.h	26 Aug 2008 23:45:35 -0000	1.160
@@ -84,7 +84,7 @@
 
 int bdb_dn2entry LDAP_P(( Operation *op, DB_TXN *tid,
 	struct berval *dn, EntryInfo **e, int matched,
-	BDB_LOCKER locker, DB_LOCK *lock ));
+	DB_LOCK *lock ));
 
 /*
  * dn2id.c
@@ -99,7 +99,7 @@
 	Operation *op,
 	struct berval *dn,
 	EntryInfo *ei,
-	BDB_LOCKER locker,
+	DB_TXN *txn,
 	DB_LOCK *lock );
 
 int bdb_dn2id_add(
@@ -121,7 +121,7 @@
 
 int bdb_dn2idl(
 	Operation *op,
-	BDB_LOCKER locker,
+	DB_TXN *txn,
 	struct berval *ndn,
 	EntryInfo *ei,
 	ID *ids,
@@ -134,7 +134,7 @@
 
 int bdb_dn2id_parent(
 	Operation *op,
-	BDB_LOCKER locker,
+	DB_TXN *txn,
 	EntryInfo *ei,
 	ID *idp );
 
@@ -174,7 +174,7 @@
 
 int bdb_filter_candidates(
 	Operation *op,
-	BDB_LOCKER locker,
+	DB_TXN *txn,
 	Filter	*f,
 	ID *ids,
 	ID *tmp,
@@ -208,7 +208,6 @@
 int bdb_id2entry(
 	BackendDB *be,
 	DB_TXN *tid,
-	BDB_LOCKER locker,
 	ID id,
 	Entry **e);
 #endif
@@ -291,7 +290,7 @@
 int bdb_idl_fetch_key(
 	BackendDB	*be,
 	DB			*db,
-	BDB_LOCKER locker,
+	DB_TXN		*txn,
 	DBT			*key,
 	ID			*ids,
 	DBC                     **saved_cursor,
@@ -398,7 +397,7 @@
 bdb_key_read(
     Backend	*be,
 	DB *db,
-	BDB_LOCKER locker,
+	DB_TXN *txn,
     struct berval *k,
 	ID *ids,
     DBC **saved_cursor,
@@ -514,7 +513,7 @@
 	EntryInfo *pei,
 	Entry   *e,
 	struct berval *nrdn,
-	BDB_LOCKER locker,
+	DB_TXN *txn,
 	DB_LOCK *lock
 );
 int bdb_cache_modrdn(
@@ -523,19 +522,19 @@
 	struct berval *nrdn,
 	Entry	*new,
 	EntryInfo *ein,
-	BDB_LOCKER locker,
+	DB_TXN *txn,
 	DB_LOCK *lock
 );
 int bdb_cache_modify(
 	struct bdb_info *bdb,
 	Entry *e,
 	Attribute *newAttrs,
-	BDB_LOCKER locker,
+	DB_TXN *txn,
 	DB_LOCK *lock
 );
 int bdb_cache_find_ndn(
 	Operation *op,
-	BDB_LOCKER	locker,
+	DB_TXN *txn,
 	struct berval   *ndn,
 	EntryInfo	**res
 );
@@ -552,20 +551,19 @@
 	ID		id,
 	EntryInfo **eip,
 	int	flag,
-	BDB_LOCKER	locker,
 	DB_LOCK		*lock
 );
 int
 bdb_cache_find_parent(
 	Operation *op,
-	BDB_LOCKER	locker,
+	DB_TXN *txn,
 	ID id,
 	EntryInfo **res
 );
 int bdb_cache_delete(
 	struct bdb_info *bdb,
 	Entry	*e,
-	BDB_LOCKER locker,
+	DB_TXN *txn,
 	DB_LOCK	*lock
 );
 void bdb_cache_delete_cleanup(
@@ -585,7 +583,7 @@
 #define bdb_cache_entry_db_relock		BDB_SYMBOL(cache_entry_db_relock)
 int bdb_cache_entry_db_relock(
 	struct bdb_info *bdb,
-	BDB_LOCKER locker,
+	DB_TXN *txn,
 	EntryInfo *ei,
 	int rw,
 	int tryOnly,
@@ -595,22 +593,10 @@
 	struct bdb_info *bdb,
 	DB_LOCK *lock );
 
-#ifdef BDB_REUSE_LOCKERS
-
-#define bdb_locker_id				BDB_SYMBOL(locker_id)
-#define bdb_locker_flush			BDB_SYMBOL(locker_flush)
-int bdb_locker_id( Operation *op, DB_ENV *env, BDB_LOCKER *locker );
-void bdb_locker_flush( DB_ENV *env );
-
-#define	LOCK_ID_FREE(env, locker)	((void)0)
-#define	LOCK_ID(env, locker)	bdb_locker_id(op, env, locker)
-
-#else
-
-#define	LOCK_ID_FREE(env, locker)	XLOCK_ID_FREE(env, locker)
-#define	LOCK_ID(env, locker)		XLOCK_ID(env, locker)
-
-#endif
+#define bdb_reader_get				BDB_SYMBOL(reader_get)
+#define bdb_reader_flush			BDB_SYMBOL(reader_flush)
+int bdb_reader_get( Operation *op, DB_ENV *env, DB_TXN **txn );
+void bdb_reader_flush( DB_ENV *env );
 
 /*
  * trans.c
Index: referral.c
===================================================================
RCS file: /repo/OpenLDAP/pkg/ldap/servers/slapd/back-bdb/referral.c,v
retrieving revision 1.50
retrieving revision 1.51
diff -u -r1.50 -r1.51
--- servers/slapd/back-bdb/referral.c	10 Mar 2008 18:28:40 -0000	1.50
+++ servers/slapd/back-bdb/referral.c	26 Aug 2008 23:45:35 -0000	1.51
@@ -28,7 +28,7 @@
 	EntryInfo *ei;
 	int rc = LDAP_SUCCESS;
 
-	BDB_LOCKER	locker;
+	DB_TXN		*rtxn;
 	DB_LOCK		lock;
 
 	if( op->o_tag == LDAP_REQ_SEARCH ) {
@@ -41,7 +41,7 @@
 		return rc;
 	} 
 
-	rc = LOCK_ID(bdb->bi_dbenv, &locker);
+	rc = bdb_reader_get(op, bdb->bi_dbenv, &rtxn);
 	switch(rc) {
 	case 0:
 		break;
@@ -51,7 +51,7 @@
 
 dn2entry_retry:
 	/* get entry */
-	rc = bdb_dn2entry( op, NULL, &op->o_req_ndn, &ei, 1, locker, &lock );
+	rc = bdb_dn2entry( op, rtxn, &op->o_req_ndn, &ei, 1, &lock );
 
 	/* bdb_dn2entry() may legally leave ei == NULL
 	 * if rc != 0 and rc != DB_NOTFOUND
@@ -65,7 +65,6 @@
 	case 0:
 		break;
 	case LDAP_BUSY:
-		LOCK_ID_FREE ( bdb->bi_dbenv, locker );
 		rs->sr_text = "ldap server busy";
 		return LDAP_BUSY;
 	case DB_LOCK_DEADLOCK:
@@ -76,7 +75,6 @@
 			LDAP_XSTRING(bdb_referrals)
 			": dn2entry failed: %s (%d)\n",
 			db_strerror(rc), rc, 0 ); 
-		LOCK_ID_FREE ( bdb->bi_dbenv, locker );
 		rs->sr_text = "internal error";
 		return LDAP_OTHER;
 	}
@@ -116,7 +114,6 @@
 			rs->sr_text = rs->sr_matched ? "bad referral object" : NULL;
 		}
 
-		LOCK_ID_FREE ( bdb->bi_dbenv, locker );
 		if (rs->sr_matched) {
 			op->o_tmpfree( (char *)rs->sr_matched, op->o_tmpmemctx );
 			rs->sr_matched = NULL;
@@ -151,6 +148,5 @@
 	}
 
 	bdb_cache_return_entry_r(bdb, e, &lock);
-	LOCK_ID_FREE ( bdb->bi_dbenv, locker );
 	return rc;
 }
Index: search.c
===================================================================
RCS file: /repo/OpenLDAP/pkg/ldap/servers/slapd/back-bdb/search.c,v
retrieving revision 1.265
retrieving revision 1.266
diff -u -r1.265 -r1.266
--- servers/slapd/back-bdb/search.c	1 May 2008 11:25:15 -0000	1.265
+++ servers/slapd/back-bdb/search.c	26 Aug 2008 23:45:35 -0000	1.266
@@ -31,7 +31,7 @@
 	Operation *op,
 	SlapReply *rs,
 	Entry *e,
-	BDB_LOCKER locker,
+	DB_TXN *txn,
 	ID	*ids,
 	ID	*scopes );
 
@@ -51,7 +51,7 @@
 	SlapReply *rs,
 	Entry *e,
 	Entry **matched,
-	BDB_LOCKER locker,
+	DB_TXN *txn,
 	DB_LOCK *lock,
 	ID	*tmp,
 	ID	*visited )
@@ -101,8 +101,8 @@
 			break;
 		}
 
-		rs->sr_err = bdb_dn2entry( op, NULL, &ndn, &ei,
-			0, locker, &lockr );
+		rs->sr_err = bdb_dn2entry( op, txn, &ndn, &ei,
+			0, &lockr );
 
 		if ( ei ) {
 			e = ei->bei_e;
@@ -143,7 +143,7 @@
 	Operation *op,
 	SlapReply *rs,
 	Entry *e,
-	BDB_LOCKER locker,
+	DB_TXN *txn,
 	ID *ids,
 	ID *scopes,
 	ID *stack )
@@ -180,7 +180,7 @@
 
 	/* Find all aliases in database */
 	BDB_IDL_ZERO( aliases );
-	rs->sr_err = bdb_filter_candidates( op, locker, &af, aliases,
+	rs->sr_err = bdb_filter_candidates( op, txn, &af, aliases,
 		curscop, visited );
 	if (rs->sr_err != LDAP_SUCCESS) {
 		return rs->sr_err;
@@ -202,7 +202,7 @@
 		 * to the cumulative list of candidates.
 		 */
 		BDB_IDL_CPY( curscop, aliases );
-		rs->sr_err = bdb_dn2idl( op, locker, &e->e_nname, BEI(e), subscop,
+		rs->sr_err = bdb_dn2idl( op, txn, &e->e_nname, BEI(e), subscop,
 			subscop2+BDB_IDL_DB_SIZE );
 		if (first) {
 			first = 0;
@@ -220,8 +220,8 @@
 		{
 			ei = NULL;
 retry1:
-			rs->sr_err = bdb_cache_find_id(op, NULL,
-				ida, &ei, 0, locker, &lockr );
+			rs->sr_err = bdb_cache_find_id(op, txn,
+				ida, &ei, 0, &lockr );
 			if (rs->sr_err != LDAP_SUCCESS) {
 				if ( rs->sr_err == DB_LOCK_DEADLOCK ||
 					rs->sr_err == DB_LOCK_NOTGRANTED ) goto retry1;
@@ -239,7 +239,7 @@
 
 			/* Actually dereference the alias */
 			BDB_IDL_ZERO(tmp);
-			a = deref_base( op, rs, a, &matched, locker, &lockr,
+			a = deref_base( op, rs, a, &matched, txn, &lockr,
 				tmp, visited );
 			if (a) {
 				/* If the target was not already in our current candidates,
@@ -286,8 +286,8 @@
 		 */
 		ei = NULL;
 sameido:
-		rs->sr_err = bdb_cache_find_id(op, NULL, ido, &ei,
-			0, locker, &locka );
+		rs->sr_err = bdb_cache_find_id(op, txn, ido, &ei,
+			0, &locka );
 		if ( rs->sr_err != LDAP_SUCCESS ) {
 			if ( rs->sr_err == DB_LOCK_DEADLOCK ||
 				rs->sr_err == DB_LOCK_NOTGRANTED )
@@ -318,7 +318,6 @@
 	int		tentries = 0, nentries = 0;
 	int		idflag = 0;
 
-	BDB_LOCKER	locker = 0;
 	DB_LOCK		lock;
 	struct	bdb_op_info	*opinfo = NULL;
 	DB_TXN			*ltid = NULL;
@@ -337,9 +336,8 @@
 
 	if ( opinfo && opinfo->boi_txn ) {
 		ltid = opinfo->boi_txn;
-		locker = TXN_ID( ltid );
 	} else {
-		rs->sr_err = LOCK_ID( bdb->bi_dbenv, &locker );
+		rs->sr_err = bdb_reader_get( op, bdb->bi_dbenv, &ltid );
 
 		switch(rs->sr_err) {
 		case 0:
@@ -362,7 +360,7 @@
 dn2entry_retry:
 		/* get entry with reader lock */
 		rs->sr_err = bdb_dn2entry( op, ltid, &op->o_req_ndn, &ei,
-			1, locker, &lock );
+			1, &lock );
 	}
 
 	switch(rs->sr_err) {
@@ -374,16 +372,12 @@
 		break;
 	case LDAP_BUSY:
 		send_ldap_error( op, rs, LDAP_BUSY, "ldap server busy" );
-		if ( !opinfo )
-			LOCK_ID_FREE (bdb->bi_dbenv, locker );
 		return LDAP_BUSY;
 	case DB_LOCK_DEADLOCK:
 	case DB_LOCK_NOTGRANTED:
 		goto dn2entry_retry;
 	default:
 		send_ldap_error( op, rs, LDAP_OTHER, "internal error" );
-		if ( !opinfo )
-			LOCK_ID_FREE (bdb->bi_dbenv, locker );
 		return rs->sr_err;
 	}
 
@@ -393,7 +387,7 @@
 
 			stub.bv_val = op->o_req_ndn.bv_val;
 			stub.bv_len = op->o_req_ndn.bv_len - matched->e_nname.bv_len - 1;
-			e = deref_base( op, rs, matched, &matched, locker, &lock,
+			e = deref_base( op, rs, matched, &matched, ltid, &lock,
 				candidates, NULL );
 			if ( e ) {
 				build_new_dn( &op->o_req_ndn, &e->e_nname, &stub,
@@ -403,7 +397,7 @@
 				goto dn2entry_retry;
 			}
 		} else if ( e && is_entry_alias( e )) {
-			e = deref_base( op, rs, e, &matched, locker, &lock,
+			e = deref_base( op, rs, e, &matched, ltid, &lock,
 				candidates, NULL );
 		}
 	}
@@ -456,8 +450,6 @@
 
 		send_ldap_result( op, rs );
 
-		if ( !opinfo )
-			LOCK_ID_FREE (bdb->bi_dbenv, locker );
 		if ( rs->sr_ref ) {
 			ber_bvarray_free( rs->sr_ref );
 			rs->sr_ref = NULL;
@@ -523,9 +515,6 @@
 		rs->sr_matched = matched_dn.bv_val;
 		send_ldap_result( op, rs );
 
-		if ( !opinfo ) {
-			LOCK_ID_FREE (bdb->bi_dbenv, locker );
-		}
 		ber_bvarray_free( rs->sr_ref );
 		rs->sr_ref = NULL;
 		ber_memfree( matched_dn.bv_val );
@@ -576,7 +565,7 @@
 		BDB_IDL_ZERO( candidates );
 		BDB_IDL_ZERO( scopes );
 		rs->sr_err = search_candidates( op, rs, &base,
-			locker, candidates, scopes );
+			ltid, candidates, scopes );
 	}
 
 	/* start cursor at beginning of candidates.
@@ -686,7 +675,7 @@
 			/* get the entry with reader lock */
 			ei = NULL;
 			rs->sr_err = bdb_cache_find_id( op, ltid,
-				id, &ei, idflag, locker, &lock );
+				id, &ei, idflag, &lock );
 
 			if (rs->sr_err == LDAP_BUSY) {
 				rs->sr_text = "ldap server busy";
@@ -931,9 +920,6 @@
 	rs->sr_err = LDAP_SUCCESS;
 
 done:
-	if ( !opinfo )
-		LOCK_ID_FREE( bdb->bi_dbenv, locker );
-
 	if( rs->sr_v2ref ) {
 		ber_bvarray_free( rs->sr_v2ref );
 		rs->sr_v2ref = NULL;
@@ -1026,7 +1012,7 @@
 	Operation *op,
 	SlapReply *rs,
 	Entry *e,
-	BDB_LOCKER locker,
+	DB_TXN *txn,
 	ID	*ids,
 	ID	*scopes )
 {
@@ -1100,13 +1086,13 @@
 	}
 
 	if( op->ors_deref & LDAP_DEREF_SEARCHING ) {
-		rc = search_aliases( op, rs, e, locker, ids, scopes, stack );
+		rc = search_aliases( op, rs, e, txn, ids, scopes, stack );
 	} else {
-		rc = bdb_dn2idl( op, locker, &e->e_nname, BEI(e), ids, stack );
+		rc = bdb_dn2idl( op, txn, &e->e_nname, BEI(e), ids, stack );
 	}
 
 	if ( rc == LDAP_SUCCESS ) {
-		rc = bdb_filter_candidates( op, locker, &f, ids,
+		rc = bdb_filter_candidates( op, txn, &f, ids,
 			stack, stack+BDB_IDL_UM_SIZE );
 	}
 
Index: tools.c
===================================================================
RCS file: /repo/OpenLDAP/pkg/ldap/servers/slapd/back-bdb/tools.c,v
retrieving revision 1.127
retrieving revision 1.128
diff -u -r1.127 -r1.128
--- servers/slapd/back-bdb/tools.c	9 Feb 2008 23:56:44 -0000	1.127
+++ servers/slapd/back-bdb/tools.c	26 Aug 2008 23:45:35 -0000	1.128
@@ -96,7 +96,7 @@
 
 	if (cursor == NULL) {
 		int rc = bdb->bi_id2entry->bdi_db->cursor(
-			bdb->bi_id2entry->bdi_db, NULL, &cursor,
+			bdb->bi_id2entry->bdi_db, bdb->bi_cache.c_txn, &cursor,
 			bdb->bi_db_opflags );
 		if( rc != 0 ) {
 			return -1;
@@ -241,6 +241,7 @@
 
 Entry* bdb_tool_entry_get( BackendDB *be, ID id )
 {
+	struct bdb_info *bdb = (struct bdb_info *) be->be_private;
 	Entry *e = NULL;
 	char *dptr;
 	int rc, eoff;
@@ -306,7 +307,7 @@
 			op.o_tmpmemctx = NULL;
 			op.o_tmpmfuncs = &ch_mfuncs;
 
-			rc = bdb_cache_find_parent( &op, CURSOR_GETLOCKER(cursor), id, &ei );
+			rc = bdb_cache_find_parent( &op, bdb->bi_cache.c_txn, id, &ei );
 			if ( rc == LDAP_SUCCESS ) {
 				bdb_cache_entryinfo_unlock( ei );
 				e->e_private = ei;
@@ -340,7 +341,7 @@
 		return 0;
 	}
 
-	rc = bdb_cache_find_ndn( op, tid ? TXN_ID( tid ) : 0, &ndn, &ei );
+	rc = bdb_cache_find_ndn( op, tid, &ndn, &ei );
 	if ( ei ) bdb_cache_entryinfo_unlock( ei );
 	if ( rc == DB_NOTFOUND ) {
 		if ( !be_issuffix( op->o_bd, &ndn ) ) {
